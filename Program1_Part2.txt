; Program 1 (for Part 2 Deliverable)
; Reads 20 numbers, stores them, prints them back.
; Then, reads one target number.
; Finds and prints the number in the list closest to the target.

LOC 30		; Start program at octal 30 (decimal 24)

; --- Part 1: Read 20 numbers into memory[100]...[119] ---
START:	LDR 0,0,COUNT		; R0 = 20 (Loop counter)
	    LDA 1,0,START_ADDR	; R1 = 100 (Array pointer)
READ_LOOP:
	    IN 2,0		; Read integer from keyboard into R2
	    STR 2,1,0		; Store R2 into memory[R1]
	    AIR 1,1		; R1 = R1 + 1 (Increment pointer)
	    SOB 0,0,READ_LOOP	; R0 = R0 - 1; Branch to READ_LOOP if R0 > 0

; --- Part 2: Print the 20 numbers back to the console ---
	    LDR 0,0,COUNT		; R0 = 20 (Loop counter)
	    LDA 1,0,START_ADDR	; R1 = 100 (Array pointer)
PRINT_LOOP:
	    LDR 2,1,0		; R2 = memory[R1]
	    OUT 2,1		; Print R2 to console
	    AIR 1,1		; R1 = R1 + 1
	    SOB 0,0,PRINT_LOOP	; R0 = R0 - 1; Branch if R0 > 0

; --- Part 3: Read target number ---
	    IN 0,0		; Read target number into R0

; --- Part 4: Find closest number ---
	    LDA 1,0,START_ADDR	; R1 = 100 (Array pointer)
	    LDR 2,1,0		; R2 = memory[100] (This is our first 'closest' guess)

	    ; Calculate initial |target - guess|
	    LDR 3,0,0		; R3 = R0 (target)
	    SMR 3,1,0		; R3 = R3 - R2 (target - guess)
	    JGE 3,0,POS_FIRST	; If (target - guess) >= 0, it's positive
	    MLT 3,2		; R3 * R2 (R2 is junk, we just need to mult by -1)
	    LDR 3,0,NEG_ONE
	    MLT 3,3         ; R3 = R3 * -1 (R3 is now positive)
POS_FIRST:
	    ; R3 now holds the first |diff|

	    LDR 0,0,COUNT		; R0 = 20 (Loop counter)
	    SIR 0,1		; R0 = 19 (We already did the first one)
	    AIR 1,1		; R1 = 101 (Point to second element)

FIND_LOOP:
	    LDR 2,0,0		; R2 = R0 (target)
	    SMR 2,1,0		; R2 = target - memory[R1] (new_diff)

	    ; Get absolute value of new_diff
	    LDR 0,0,2		; R0 = new_diff
	    JGE 0,0,POS_NEW		; If new_diff >= 0, it's positive
	    LDR 0,0,NEG_ONE
	    MLT 0,0         ; R0 = new_diff * -1 (absolute value)
POS_NEW:
	    ; R0 has new |diff|, R3 has old |diff|
	    SMR 0,0,3		; R0 = new |diff| - old |diff|
	    JGE 0,0,NO_UPDATE	; If (new_diff - old_diff) >= 0, new is NOT better

	    ; Update: new_diff is smaller
	    LDR 0,0,2		; R0 = new_diff
	    JGE 0,0,POS_UPDATE	; Get absolute value of new_diff again
	    LDR 0,0,NEG_ONE
	    MLT 0,0
POS_UPDATE:
	    LDR 3,0,0		; R3 = R0 (update old_diff)
	    LDR 2,1,0		; R2 = memory[R1] (This is the new 'closest' guess)

NO_UPDATE:
	    AIR 1,1		; R1 = R1 + 1
	    LDR 0,0,COUNT
	    SMR 0,0,1       ; R0 = count - 1 (for SOB)
	    SOB 0,0,FIND_LOOP

; --- Part 5: Print the final result ---
	    OUT 2,1		; Print the closest value found (in R2)

	    HLT			; Stop

; --- Data Section ---
; Place data *after* HLT so it's not executed by accident
START_ADDR: DATA 100	; Array starts at address 100 (octal)
COUNT: 	    DATA 20	; We will read 20 (decimal) numbers
ONE:	    DATA 1
NEG_ONE:    DATA -1